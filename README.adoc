= musecnav
:toc: top
:toclevels: 3
:experimental:
:icons: font
// Stupid GitHub doing things their own stupid way. This is to match locally. (The
// default is, of course, underscore for both.)
:idprefix:
:idseparator: -
//:sectlinks:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
//:hide-uri-scheme:
// :source-language: python
ifdef::env-github[]
:toc-placement!:
toc::[]
endif::[]

_Musecnav_ (**M**ark**U**p **SEC**tion **NAV**igation) is a Vim plugin that allows
allows quick navigation of sections in <<section-headers, well-formed>> Asciidoc and
Markdown documents.

image::screenshots/example1.png[488,530,example]

___

.8/28/2022 Update
[IMPORTANT]
====

I've done an almost complete rewrite of the code making it easier to maintain and
improve the plugin (and I plan on doing both those things for the foreseeable
future). My hope is that you won't have any problems but in that unfortunate event...

* Please report it by creating a new _issue_.
* If you need it, the previous version has been tagged with `pre-redesign`.

Otherwise, the changes should be mostly transparent to you with one exception: there
is a new section display mode, 'ancestor'. This is the new default mode, replacing
'selected' as I believe it is more practical. If you prefer the old default you can
change it back with the `musecnav_display_mode` setting. All of the details are in
<<section-display-modes>>.
====

== Overview

TIP: If you just want to jump in and go a quick read of <<hot-keys, Hot Keys>> should be
all that you need after installation.

I regularly edit files containing markup. Moving from section to section is quite a
pain, especially in large files, so I created this plugin to display a section
navigation menu.

Basically, _musecnav_ works like this: open the navigation menu and navigate through
the section hierarchy using Enter to select/expand sections. When you get to the
section you were looking for close the menu and the cursor will be positioned at that
section's header. 

The menu is updated, as necessary, each time it's opened so it accurately reflects
the document's section hierarchy and the current cursor position. There are several
<<section-display-modes>> available so you can, for example, configure the plugin to
always show the hierarchy fully expanded or to only expand the subtree within which
the cursor lies. There are a few other ways to customize the menu, too, as described
in <<settings>>.

== Installation

WARNING: _Musecnav_ relies on Vim's syntax highlighting feature to augment its
section detection. If you're not using standard Vim syntax files for
Markdown/Asciidoc please see <<compatibility>>.

Standard stuff here. If you use a plugin manager that plays nice with GitHub you
probably know what to do. Using vim-plug as an example...

.vim-plug configuration
----
Plug 'b-layer/musecnav'
----

If you use Vim packages use git from the command line as follows.

.Vim package cloning (Unix/Linux)
----
git clone https://github.com/b-layer/musecnav.git ~/.vim/pack/{packdir}/start/musecnav
----

Replace `{packdir}` with whatever directory name you prefer.

(On Windows you'll likely be using `%USERPROFILE%/vimfiles` in place of `~/.vim`.)

== Hot Keys

=== Default Key Map

By default no keys are mapped. To enable the hotkey assignments described below add
the following to your vimrc file:

    let g:musecnav_use_default_keymap = 1

Otherwise see <<key-mappings, Key Mappings>> for help with defining your
own hotkeys.

WARNING: Since we don't want to override any of your existing key mappings you need
to explicitly configure this plugin's hot keys. If the default key assignments for
menu open and reset functions (namely kbd:[F7], kbd:[Shift+F7] and kbd:[Ctrl+F7])
don't conflict with your setup then all you need to do is to add the above line and
you're ready to start using _musecnav_.

=== Opening the Menu

kbd:[F7] :: Open the navigation menu.

=== Menu Navigation

If your version of Vim supports popups (i.e. version 8.1.1517 or later) the menu will
appear in a popup window. Otherwise it will appear as a "drawer" that slides up from
the bottom of the window. Note that navigation in the slide-up menu is somewhat
limited compared to the popup.

==== Popup

kbd:[J]/kbd:[K] or kbd:[Down]/kbd:[Up] :: Select next/previous row.

kbd:[Shift+J]/kbd:[Shift+K] :: Select last/first row. 

Numbers 1-99 :: Select row corresponding to the entered number(s) (see the sidebar).

kbd:[Enter] :: Move the cursor to the section header matching the selected row. The
               section's subtree, if any, will become visible if it wasn't already.
               The popup will remain open. If you hit kbd:[Enter] a second time
               within a couple seconds the popup will be closed.

kbd:[Esc], kbd:[Ctrl+C] or kbd:[X] :: Close the navigation menu popup.

.Numerical Selection in the Popup
****
A nice feature is being able to choose sections by entering their associated number.
(By default Vim menu popups don't support this which means you might have 50 sections
on screen but no way to navigate them except up or down, one line at a time!) That
being said, the way things are implemented _might_ seem a little peculiar so the
algorithm is detailed here...

There is a 1-digit "buffer" that is empty when the menu is opened.

* User enters a number when buffer is empty...
** ...if number matches a single row and is not the first digit of any other row
   numbers then select the matching row (the buffer remains empty).
** ...if number could match multiple rows select the first of the potential matches
   and store the number in the buffer.
* User enters a number when buffer is not empty...
** ...if combined number (previous is most significant digit, new is least
   significat) matches a single row, select that row and clear buffer.
** ...if combined number doesn't match a row, discard new number (previous number
   remains in buffer)

Example: 32 rows. User enters 3. Select line 3 and store num in buffer (in case they
intend to go to 30, 31 or 32). User then enters 5. No row 35 so discard 5 (leaving 3
in buffer and row 3 selected) User enters 1. Select row 31 and clear buffer. User
enters 9. Select row 9 but don't buffer num (since no other row nums start with 9).
User enters 2. Select row 2 and buffer num. Etc. When user finally accepts selection
with Enter buffer is always cleared.

If you get confused hit Enter and retype desired number. (Though, really, it's not
THAT confusing. ;) 

CAUTION: This currently only works for 2-digit numbers so if you have 100 or more
sections visible in the menu at one time the behavior is undefined. If you are
impacted by this please report it.

****

==== Slide-Up Drawer

Numbers 1-99 :: Rows are chosen by entering their associated number followed by Enter.
kbd:[Esc] / kbd:[Ctrl+C] or kbd:[Enter] by itself :: Close the menu.


=== Reset

_musecnav_ monitors the current buffer and if it detects a change that could impact
the _location_ of any sections in the saved hierarchy it will rescan the file and
show the updated hierarchy the next time the menu is opened. However, a change that
doesn't effect section locations, such as modifying a section title, will not result
in a rescan. In cases like this you can force a rescan with one of these reset
functions:

kbd:[Shift+F7] :: "Soft" reset. Clear section data, rescan section headers and open
                  the navigation menu. This will identify section title changes.

kbd:[Ctrl+F7] :: "Hard" reset. Clear all state, rescan section headers and, for
                 Asciidoc, any document headers and open the navigation menu. If, for
                 some reason, a soft reset didn't pick up a particular change this
                 will.

== Settings

Unless otherwise noted, settings based on Vim variables can be configured either
as buffer-local or global. The differences are described below.

.Buffer-local variables...
* Have prefix `b:`.
* Are usually set on the command line of an open buffer.
* Affect _musecnav_ only in the buffer in which they are set.
* Take effect the next time the navigation menu is opened.
* Example: `let b:musecnav_display_mode = 'all'`

.Global variables...
* Have prefix `g:`.
* Are usually added to your vimrc file.
* Affect only buffers that are opened after the setting is added to your vimrc.
* Example: `let g:musecnav_display_mode = 'all'`

=== Key Mappings

As mentioned in the <<hot-keys, Hot Keys>> section you can enable default key
mappings by adding the following to your vimrc file:

    let g:musecnav_use_default_keymap = 1

If you'd prefer to define your own mappings it works like most plugins out there:
find the applicable `<Plug>` mappings and map the desired key(s) to the ones of
interest. You can find the `<Plug>` mappings for _musecnav_ by running the following
command while editing an Asciidoc or Markdown document:

    filter /musecnav/ map

IMPORTANT: Only functions used in the regular edit window are mappable. All of the
in-menu navigation keys are currently hard-coded. Contact me if this is a problem for
you.

The most important one is that which launches the navigation menu/popup.
Specifically, `<Plug>MusecnavNavigate`. A valid mapping to that would look like this:

        nmap <F7> <Plug>MusecnavNavigate

The only other `<Plug>` mappings you might want to consider configuring are
`<Plug>MusecnavReset` and `<Plug>MusecnavReinit`. Their functionality is described
here: <<reset, Hot Keys - Reset>>.

==== Swapping Function Keys

If you'd like to continue using a function key for the menu launch and reset
functions but prefer one other than kbd:[F7] then all you need to do other than
enabling `g:musecnav_use_default_keymap` is to specify which function key in
`g:musecnav_alt_fun_key`. For example, if you'd like to use kbd:[F3] to open the
navigation window add this to your vimrc file:

    let g:musecnav_alt_fun_key = 'F3'

This will also change the mappings for soft and hard resets, too, i.e. to
kbd:[Shift+F3] and kbd:[Ctrl+F3], respectively.

=== Section Display Modes

As you navigate through a document hierarchy, section visibility changes. Some
sections will be hidden and some will be visible. This visibility is determined by
a set of rules. A specific set of activated rules is referred to as a display mode.
The user can choose which of the available display modes will be used.

Regardless of which display mode is selected, the following is always true:

_The currently selected section along with all of its sibling, ancestor and
descendant sections will always be visible._

Additional rules are determined by the display mode name currently assigned to the
`musecnav_display_mode` setting. The available modes, from most to least restrictive,
are _selected_, _ancestor_ and _all_. The sections that will be displayed for each of
these modes are:

.selected
* All top level sections
* The selected section
* The selected section's ancestors, siblings and descendants

.ancestor
* All top level sections
* The selected section
* The selected section's top-level ancestor and all of the ancestor's descendants.

.all
* All sections

The default display mode is 'ancestor'.

Note: you may use abbreviated mode names as long as at least the first three letters
are present.

==== Other Ways to Change the Mode

You can avoid setting `b:musecnav_display_mode` manually by using the user commands
`MusecnavNextLayout` and `MusecnavPrevLayout`. These cycle forward and back,
respectively, through the available settings.

The same underlying functionality is available for key mapping as shown in these
examples:

    nmap <leader>N <Plug>MusecnavNextLayout
    nmap <leader>P <Plug>MusecnavPrevLayout

=== Popup Placement

If you are using the popup menu it will by default appear on the right side of the
window, centered vertically. If you want it to appear further left you can specify
the column at which the popup's left side should be located with `musecnav_pop_col`.

For example, to have the popup open with its left side at column 50 in the current
buffer:

    let b:musecnav_pop_col = 50

=== Popup Menu Colors

If you are using the popup menu, note that Vim popups are colored based on highlight
groups `Popup` and `PopupSelected` or, if those are not set, `PMenu` and `PMenuSel`.
Because popups are relatively new you'll find that `Popup`/`PopupSelected` are rarely
set in color schemes. That means the `PMenu` groups are used and those aren't
explicitly set too often either which means you end up with the default for `PMenu`
which is a garish pink/magenta. So I decided to define the two `Popup*` groups by
default. Instead of a fixed set of colors, though, I link them to other highlight
groups. This way they will match (usually) whatever color scheme you are currently
using.

If you still want to override them you are free to. Example:

    hi Popup guifg=#3030ff guibg=black
    hi PopupSelected guifg=black guibg=#a0a0ff

=== Other Settings

==== Menu Type

Choose whether to use the popup or slide-up navigation menu with
`musecnav_use_popup`.

For example, to use the slide-up in all future runs of _musecnav_ add to your vimrc:

    let g:musecnav_use_popup = 0

Of course, if your version of Vim doesn't support popups then setting this to 1 will
have no effect.

==== Current Section Indicator

Change the in-menu 'current section' indicator with `musecnav_place_mark`. By
default, this is set to the character `▶`.

For example, to change the marker to a double angle bracket in the current buffer run
this from the command line:

    let b:musecnav_place_mark = '≫'

== Section Headers

*This plugin will not work correctly if you do not use use valid section header
syntax and semantics.*

.Markdown requirements
* Vim's syntax highlighting feature _must_ be enabled.
* Use a header format recognized by the syntax highlighting in Vim.
* Use legal section flow, i.e. _don't skip section levels when ascending_.

.Asciidoc requirements
* Use a header format allowed per the Asiidoc spec.
* Use legal section flow, i.e. _don't skip section levels when ascending_.

While syntax highlighting doesn't have to be enabled for Asciidoc navigation it's
recommended as it will likely improve results when editing complex markup.

NOTE: For most _doctypes_ Asciidoc allows a _document header_ to be added to the
beginning of a document. They are marked by a single `=` (or `#`) and are considered
level 0 headers. They are treated by _musecnav_ as a special level 1 section header
denoting the start of a document. (_Musecnav_ doesn't currently support the "book"
doctype which allows multiple level 0 headers but this feature is on the roadmap.)

== Compatibility

As noted previously _musecnav_ makes use of Vim's syntax highlighting feature to
augment its section searching. If you are using a custom Asciidoc or Markdown syntax
file with different highlight group names the plugin may not work well.

Besides Vim's default syntax files _musecnav_ has been tested with those from the
following popular plugins:

* https://github.com/dahu/vim-asciidoc[dahu/vim-asciidoc]
* https://github.com/habamax/vim-asciidoctor[habamax/vim-asciidoctor]
* https://github.com/plasticboy/vim-markdown[plasticboy/vim-markdown]

If you'd like there to be compatibility with another plugin's syntax file create a
new issue.

As a workaround, if you're using using Asciidoc you can try disabling _musecnav's_
use of Vim's synhi by adding this to your vimrc:

    let g:musecnav_use_ad_synhi = 0

This will likely help in your case but with complex markup there may be misidentified
sections.

== Roadmap

Some things I have in mind for future versions of _musecnav_:

* [AD] Handle different doctypes (e.g. book with multiple level 0 headers)
* [AD] Handle included files
* Neovim support
* Other ideas? 

